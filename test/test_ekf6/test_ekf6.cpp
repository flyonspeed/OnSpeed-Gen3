/**
 * @file test_ekf6.cpp
 * @brief Unit tests for EKF6 (6-state Extended Kalman Filter)
 *
 * Tests compare C++ implementation against Octave reference data
 * generated by octave_reference/ekf6_reference.m
 */

#include <unity.h>
#include <EKF6.h>
#include <cmath>
#include <cstdio>
#include <vector>
#include <string>

using namespace onspeed;

// Test configuration
static constexpr float DT = 1.0f / 208.0f;  // 208 Hz sample rate
static constexpr float DEG2RAD = 3.14159265358979f / 180.0f;
static constexpr float RAD2DEG = 180.0f / 3.14159265358979f;
static constexpr float G = 9.80665f;

// Tolerance for floating point comparison
static constexpr float ABS_TOL = 0.01f;  // 0.01 degrees

void setUp(void) {}
void tearDown(void) {}

// ============================================================================
// Basic Functionality Tests
// ============================================================================

void test_ekf6_initialization(void) {
    EKF6 ekf;
    ekf.init(0.0f, 0.0f);

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.phi);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.theta);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.alpha);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.bp);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.bq);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.br);
}

void test_ekf6_initialization_with_attitude(void) {
    EKF6 ekf;
    ekf.init(10.0f * DEG2RAD, 5.0f * DEG2RAD);

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.01f, 10.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.01f, 5.0f, state.theta_deg());
}

void test_ekf6_state_accessors(void) {
    EKF6 ekf;
    ekf.init(15.0f * DEG2RAD, -8.0f * DEG2RAD);

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.01f, 15.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.01f, -8.0f, state.theta_deg());
}

// ============================================================================
// Level Flight Test
// ============================================================================

void test_ekf6_level_flight(void) {
    // Level flight: accelerometer shows [0, 0, -g], no gyro rates
    // Filter should maintain phi=0, theta=0

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run for 5 seconds at 208 Hz
    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Should converge to level
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.theta_deg());
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.alpha_deg());
}

// ============================================================================
// Pitched Attitude Test
// ============================================================================

void test_ekf6_pitched_10deg(void) {
    // 10 degree pitch up: accelerometer shows [g*sin(10deg), 0, -g*cos(10deg)]
    float theta_true = 10.0f * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = 0.0f,
        .az = -G * std::cos(theta_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 10.0f, state.theta_deg());  // Within 0.1 deg
}

// ============================================================================
// Banked Attitude Test
// ============================================================================

void test_ekf6_banked_20deg(void) {
    // 20 degree bank: accelerometer shows [0, -g*sin(20deg), -g*cos(20deg)]
    float phi_true = 20.0f * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = -G * std::sin(phi_true),
        .az = -G * std::cos(phi_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.1f, 20.0f, state.phi_deg());  // Within 0.1 deg
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.theta_deg());
}

// ============================================================================
// Pitch Rate Integration Test
// ============================================================================

void test_ekf6_pitch_rate_integration(void) {
    // Pitch up at 5 deg/s for 2 seconds, then hold
    // Expected final theta = 10 degrees

    float pitch_rate = 5.0f * DEG2RAD;  // rad/s
    float pitch_duration = 2.0f;        // seconds

    EKF6 ekf;
    ekf.init();

    float theta_true = 0.0f;
    int n_samples = static_cast<int>(5.0f / DT);

    for (int i = 0; i < n_samples; i++) {
        float t = i * DT;

        // Apply pitch rate for specified duration
        float q;
        if (t < pitch_duration) {
            q = pitch_rate;
            theta_true += pitch_rate * DT;
        } else {
            q = 0.0f;
        }

        // True accelerometer based on current pitch
        EKF6::Measurements meas = {
            .ax = G * std::sin(theta_true),
            .ay = 0.0f,
            .az = -G * std::cos(theta_true),
            .p = 0.0f,
            .q = q,
            .r = 0.0f,
            .gamma = 0.0f
        };

        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();
    float expected_theta = pitch_rate * pitch_duration * RAD2DEG;

    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.5f, expected_theta, state.theta_deg());  // Within 0.5 deg
}

// ============================================================================
// Gyro Bias Estimation Test
// ============================================================================

void test_ekf6_gyro_bias_estimation(void) {
    // Level flight with constant pitch gyro bias of 2 deg/s
    // Filter should keep attitude near level and estimate bias

    float bias_dps = 2.0f;
    float q_bias = bias_dps * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = q_bias,  // Gyro reads bias even though aircraft is level
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Theta should stay near zero (accelerometer corrects drift)
    TEST_ASSERT_FLOAT_WITHIN(1.0f, 0.0f, state.theta_deg());

    // Note: Bias estimation converges slowly with this tuning
    // The Octave reference shows bq ~0.39 after 5 seconds
    // Just verify it's moving in the right direction
    TEST_ASSERT_TRUE(state.bq_dps() > 0.0f);
}

// ============================================================================
// Numerical Stability Tests
// ============================================================================

void test_ekf6_no_nan_output(void) {
    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run for 10 seconds
    int n_samples = static_cast<int>(10.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FALSE(std::isnan(state.phi));
    TEST_ASSERT_FALSE(std::isnan(state.theta));
    TEST_ASSERT_FALSE(std::isnan(state.alpha));
    TEST_ASSERT_FALSE(std::isnan(state.bp));
    TEST_ASSERT_FALSE(std::isnan(state.bq));
    TEST_ASSERT_FALSE(std::isnan(state.br));
}

void test_ekf6_zero_dt_handling(void) {
    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Zero dt should not crash
    ekf.update(meas, 0.0f);

    EKF6::State state = ekf.getState();
    TEST_ASSERT_FALSE(std::isnan(state.phi));
    TEST_ASSERT_FALSE(std::isnan(state.theta));
}

void test_ekf6_large_attitude_stability(void) {
    // Test with large attitude angles (45 deg pitch and roll)
    float phi_true = 45.0f * DEG2RAD;
    float theta_true = 45.0f * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    // Accelerometer for combined pitch/roll
    float ax = G * std::sin(theta_true);
    float ay = -G * std::cos(theta_true) * std::sin(phi_true);
    float az = -G * std::cos(theta_true) * std::cos(phi_true);

    EKF6::Measurements meas = {
        .ax = ax,
        .ay = ay,
        .az = az,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Should not be NaN
    TEST_ASSERT_FALSE(std::isnan(state.phi));
    TEST_ASSERT_FALSE(std::isnan(state.theta));

    // Should be reasonably close to true values
    TEST_ASSERT_FLOAT_WITHIN(5.0f, 45.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(5.0f, 45.0f, state.theta_deg());
}

// ============================================================================
// Custom Configuration Test
// ============================================================================

void test_ekf6_custom_config(void) {
    EKF6::Config cfg = EKF6::Config::defaults();
    cfg.r_accel = 0.1f;  // Lower accelerometer noise = faster convergence

    EKF6 ekf(cfg);
    ekf.init();

    // 10 degree pitch
    float theta_true = 10.0f * DEG2RAD;
    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = 0.0f,
        .az = -G * std::cos(theta_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run for just 1 second - should converge faster with lower noise
    int n_samples = static_cast<int>(1.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Should be close to 10 deg even after only 1 second
    TEST_ASSERT_FLOAT_WITHIN(1.0f, 10.0f, state.theta_deg());
}

// ============================================================================
// Main
// ============================================================================

int main(int argc, char **argv) {
    UNITY_BEGIN();

    // Basic tests
    RUN_TEST(test_ekf6_initialization);
    RUN_TEST(test_ekf6_initialization_with_attitude);
    RUN_TEST(test_ekf6_state_accessors);

    // Attitude estimation tests
    RUN_TEST(test_ekf6_level_flight);
    RUN_TEST(test_ekf6_pitched_10deg);
    RUN_TEST(test_ekf6_banked_20deg);
    RUN_TEST(test_ekf6_pitch_rate_integration);
    RUN_TEST(test_ekf6_gyro_bias_estimation);

    // Numerical stability tests
    RUN_TEST(test_ekf6_no_nan_output);
    RUN_TEST(test_ekf6_zero_dt_handling);
    RUN_TEST(test_ekf6_large_attitude_stability);

    // Configuration test
    RUN_TEST(test_ekf6_custom_config);

    return UNITY_END();
}
