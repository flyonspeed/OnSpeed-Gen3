/**
 * @file test_ekf6.cpp
 * @brief Unit tests for EKF6 (6-state Extended Kalman Filter)
 *
 * Tests compare C++ implementation against Octave reference data
 * generated by octave_reference/ekf6_reference.m
 */

#include <unity.h>
#include <EKF6.h>
#include <cmath>
#include <cstdio>
#include <vector>
#include <string>

using namespace onspeed;

// Test configuration
static constexpr float DT = 1.0f / 208.0f;  // 208 Hz sample rate
static constexpr float DEG2RAD = 3.14159265358979f / 180.0f;
static constexpr float RAD2DEG = 180.0f / 3.14159265358979f;
static constexpr float G = 9.80665f;

// Tolerance for floating point comparison
static constexpr float ABS_TOL = 0.01f;  // 0.01 degrees

void setUp(void) {}
void tearDown(void) {}

// ============================================================================
// Basic Functionality Tests
// ============================================================================

void test_ekf6_initialization(void) {
    EKF6 ekf;
    ekf.init(0.0f, 0.0f);

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.phi);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.theta);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.alpha);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.bp);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.bq);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, 0.0f, state.br);
}

void test_ekf6_initialization_with_attitude(void) {
    EKF6 ekf;
    ekf.init(10.0f * DEG2RAD, 5.0f * DEG2RAD);

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.01f, 10.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.01f, 5.0f, state.theta_deg());
}

void test_ekf6_state_accessors(void) {
    EKF6 ekf;
    ekf.init(15.0f * DEG2RAD, -8.0f * DEG2RAD);

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.01f, 15.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.01f, -8.0f, state.theta_deg());
}

// ============================================================================
// Level Flight Test
// ============================================================================

void test_ekf6_level_flight(void) {
    // Level flight: accelerometer shows [0, 0, -g], no gyro rates
    // Filter should maintain phi=0, theta=0

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run for 5 seconds at 208 Hz
    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Should converge to level
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.theta_deg());
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.alpha_deg());
}

// ============================================================================
// Pitched Attitude Test
// ============================================================================

void test_ekf6_pitched_10deg(void) {
    // 10 degree pitch up: accelerometer shows [g*sin(10deg), 0, -g*cos(10deg)]
    float theta_true = 10.0f * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = 0.0f,
        .az = -G * std::cos(theta_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 10.0f, state.theta_deg());  // Within 0.1 deg
}

// ============================================================================
// Banked Attitude Test
// ============================================================================

void test_ekf6_banked_20deg(void) {
    // 20 degree bank: accelerometer shows [0, -g*sin(20deg), -g*cos(20deg)]
    float phi_true = 20.0f * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = -G * std::sin(phi_true),
        .az = -G * std::cos(phi_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FLOAT_WITHIN(0.1f, 20.0f, state.phi_deg());  // Within 0.1 deg
    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.theta_deg());
}

// ============================================================================
// Pitch Rate Integration Test
// ============================================================================

void test_ekf6_pitch_rate_integration(void) {
    // Pitch up at 5 deg/s for 2 seconds, then hold
    // Expected final theta = 10 degrees

    float pitch_rate = 5.0f * DEG2RAD;  // rad/s
    float pitch_duration = 2.0f;        // seconds

    EKF6 ekf;
    ekf.init();

    float theta_true = 0.0f;
    int n_samples = static_cast<int>(5.0f / DT);

    for (int i = 0; i < n_samples; i++) {
        float t = i * DT;

        // Apply pitch rate for specified duration
        float q;
        if (t < pitch_duration) {
            q = pitch_rate;
            theta_true += pitch_rate * DT;
        } else {
            q = 0.0f;
        }

        // True accelerometer based on current pitch
        EKF6::Measurements meas = {
            .ax = G * std::sin(theta_true),
            .ay = 0.0f,
            .az = -G * std::cos(theta_true),
            .p = 0.0f,
            .q = q,
            .r = 0.0f,
            .gamma = 0.0f
        };

        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();
    float expected_theta = pitch_rate * pitch_duration * RAD2DEG;

    TEST_ASSERT_FLOAT_WITHIN(ABS_TOL, 0.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(0.5f, expected_theta, state.theta_deg());  // Within 0.5 deg
}

// ============================================================================
// Gyro Bias Estimation Test
// ============================================================================

void test_ekf6_gyro_bias_estimation(void) {
    // Level flight with constant pitch gyro bias of 2 deg/s
    // Filter should keep attitude near level and estimate bias

    float bias_dps = 2.0f;
    float q_bias = bias_dps * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = q_bias,  // Gyro reads bias even though aircraft is level
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Theta should stay near zero (accelerometer corrects drift)
    TEST_ASSERT_FLOAT_WITHIN(1.0f, 0.0f, state.theta_deg());

    // Note: Bias estimation converges slowly with this tuning
    // The Octave reference shows bq ~0.39 after 5 seconds
    // Just verify it's moving in the right direction
    TEST_ASSERT_TRUE(state.bq_dps() > 0.0f);
}

// ============================================================================
// Numerical Stability Tests
// ============================================================================

void test_ekf6_no_nan_output(void) {
    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run for 10 seconds
    int n_samples = static_cast<int>(10.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    TEST_ASSERT_FALSE(std::isnan(state.phi));
    TEST_ASSERT_FALSE(std::isnan(state.theta));
    TEST_ASSERT_FALSE(std::isnan(state.alpha));
    TEST_ASSERT_FALSE(std::isnan(state.bp));
    TEST_ASSERT_FALSE(std::isnan(state.bq));
    TEST_ASSERT_FALSE(std::isnan(state.br));
}

void test_ekf6_zero_dt_handling(void) {
    EKF6 ekf;
    ekf.init();

    EKF6::Measurements meas = {
        .ax = 0.0f,
        .ay = 0.0f,
        .az = -G,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Zero dt should not crash
    ekf.update(meas, 0.0f);

    EKF6::State state = ekf.getState();
    TEST_ASSERT_FALSE(std::isnan(state.phi));
    TEST_ASSERT_FALSE(std::isnan(state.theta));
}

void test_ekf6_large_attitude_stability(void) {
    // Test with large attitude angles (45 deg pitch and roll)
    float phi_true = 45.0f * DEG2RAD;
    float theta_true = 45.0f * DEG2RAD;

    EKF6 ekf;
    ekf.init();

    // Accelerometer for combined pitch/roll
    float ax = G * std::sin(theta_true);
    float ay = -G * std::cos(theta_true) * std::sin(phi_true);
    float az = -G * std::cos(theta_true) * std::cos(phi_true);

    EKF6::Measurements meas = {
        .ax = ax,
        .ay = ay,
        .az = az,
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Should not be NaN
    TEST_ASSERT_FALSE(std::isnan(state.phi));
    TEST_ASSERT_FALSE(std::isnan(state.theta));

    // Should be reasonably close to true values
    TEST_ASSERT_FLOAT_WITHIN(5.0f, 45.0f, state.phi_deg());
    TEST_ASSERT_FLOAT_WITHIN(5.0f, 45.0f, state.theta_deg());
}

// ============================================================================
// Custom Configuration Test
// ============================================================================

void test_ekf6_custom_config(void) {
    EKF6::Config cfg = EKF6::Config::defaults();
    cfg.r_accel = 0.1f;  // Lower accelerometer noise = faster convergence

    EKF6 ekf(cfg);
    ekf.init();

    // 10 degree pitch
    float theta_true = 10.0f * DEG2RAD;
    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = 0.0f,
        .az = -G * std::cos(theta_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run for just 1 second - should converge faster with lower noise
    int n_samples = static_cast<int>(1.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State state = ekf.getState();

    // Should be close to 10 deg even after only 1 second
    TEST_ASSERT_FLOAT_WITHIN(1.0f, 10.0f, state.theta_deg());
}

// ============================================================================
// Alpha Covariance Reset Tests
// ============================================================================

void test_ekf6_reset_alpha_covariance_basic(void) {
    // Simulate ground/taxi: run 30 seconds with gamma=0 (alpha tracks theta).
    // Then reset alpha covariance, introduce gamma=3deg step, and verify
    // alpha converges to theta-gamma within 0.5 seconds.
    //
    // Use low q_alpha (1e-6) to model slow alpha dynamics — this makes
    // the covariance shrink during ground time, so the reset effect is
    // clearly visible.

    EKF6::Config cfg = EKF6::Config::defaults();
    cfg.q_alpha = 1e-6f;
    EKF6 ekf(cfg);
    float theta_true = 5.0f * DEG2RAD;  // 5 deg pitch

    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = 0.0f,
        .az = -G * std::cos(theta_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f  // ground: no flight path info
    };

    // Run 30 seconds at 208 Hz — P_[2][2] shrinks, filter becomes very confident
    int n_ground = static_cast<int>(30.0f / DT);
    for (int i = 0; i < n_ground; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State pre_reset = ekf.getState();
    // Alpha should be close to theta (since gamma=0 the whole time)
    TEST_ASSERT_FLOAT_WITHIN(0.5f, 5.0f, pre_reset.alpha_deg());

    // Reset alpha covariance — tells filter to re-learn alpha
    ekf.resetAlphaCovariance();

    // Now introduce gamma=3deg step (takeoff)
    float gamma_new = 3.0f * DEG2RAD;
    float alpha_expected = (theta_true - gamma_new) * RAD2DEG;  // 2.0 deg
    meas.gamma = gamma_new;

    // Run 0.5 seconds — should converge quickly after reset
    int n_converge = static_cast<int>(0.5f / DT);
    for (int i = 0; i < n_converge; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State post = ekf.getState();
    TEST_ASSERT_FLOAT_WITHIN(0.5f, alpha_expected, post.alpha_deg());
}

void test_ekf6_stale_alpha_without_reset(void) {
    // Same scenario as above but WITHOUT reset — proves the problem exists.
    // With low q_alpha, the covariance shrinks during ground time and
    // convergence to the new alpha value is dramatically slower.

    EKF6::Config cfg = EKF6::Config::defaults();
    cfg.q_alpha = 1e-6f;
    EKF6 ekf(cfg);
    float theta_true = 5.0f * DEG2RAD;

    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = 0.0f,
        .az = -G * std::cos(theta_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    int n_ground = static_cast<int>(30.0f / DT);
    for (int i = 0; i < n_ground; i++) {
        ekf.update(meas, DT);
    }

    // NO reset — introduce gamma step
    float gamma_new = 3.0f * DEG2RAD;
    float alpha_expected = (theta_true - gamma_new) * RAD2DEG;  // 2.0 deg
    meas.gamma = gamma_new;

    // Run only 0.5 seconds (same as the reset test)
    int n_converge = static_cast<int>(0.5f / DT);
    for (int i = 0; i < n_converge; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State post = ekf.getState();
    // Without reset, alpha should still be far from the expected value
    // (convergence is slow because P_[2][2] is tiny after 30s ground)
    float error = std::fabs(post.alpha_deg() - alpha_expected);
    TEST_ASSERT_TRUE_MESSAGE(error > 0.5f,
        "Alpha converged too fast without reset — stale covariance problem not demonstrated");
}

void test_ekf6_reset_alpha_covariance_uninitialized(void) {
    // Calling resetAlphaCovariance on an uninitialized filter should not crash
    EKF6::Config cfg = EKF6::Config::defaults();

    // Construct without init — the constructor calls init() internally,
    // so we need to verify reset works on a freshly constructed filter too
    EKF6 ekf(cfg);

    // Should not crash or produce NaN
    ekf.resetAlphaCovariance();

    EKF6::State state = ekf.getState();
    TEST_ASSERT_FALSE(std::isnan(state.alpha));
}

void test_ekf6_reset_preserves_other_states(void) {
    // After resetAlphaCovariance, phi/theta/biases should be unchanged

    EKF6 ekf;
    float theta_true = 10.0f * DEG2RAD;
    float phi_true = 15.0f * DEG2RAD;

    EKF6::Measurements meas = {
        .ax = G * std::sin(theta_true),
        .ay = -G * std::cos(theta_true) * std::sin(phi_true),
        .az = -G * std::cos(theta_true) * std::cos(phi_true),
        .p = 0.0f,
        .q = 0.0f,
        .r = 0.0f,
        .gamma = 0.0f
    };

    // Run 5 seconds to settle
    int n_samples = static_cast<int>(5.0f / DT);
    for (int i = 0; i < n_samples; i++) {
        ekf.update(meas, DT);
    }

    EKF6::State before = ekf.getState();

    // Reset alpha covariance
    ekf.resetAlphaCovariance();

    EKF6::State after = ekf.getState();

    // All states should be identical (reset only touches P, not x)
    TEST_ASSERT_FLOAT_WITHIN(0.001f, before.phi, after.phi);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, before.theta, after.theta);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, before.alpha, after.alpha);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, before.bp, after.bp);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, before.bq, after.bq);
    TEST_ASSERT_FLOAT_WITHIN(0.001f, before.br, after.br);
}

// ============================================================================
// Main
// ============================================================================

int main(int argc, char **argv) {
    UNITY_BEGIN();

    // Basic tests
    RUN_TEST(test_ekf6_initialization);
    RUN_TEST(test_ekf6_initialization_with_attitude);
    RUN_TEST(test_ekf6_state_accessors);

    // Attitude estimation tests
    RUN_TEST(test_ekf6_level_flight);
    RUN_TEST(test_ekf6_pitched_10deg);
    RUN_TEST(test_ekf6_banked_20deg);
    RUN_TEST(test_ekf6_pitch_rate_integration);
    RUN_TEST(test_ekf6_gyro_bias_estimation);

    // Numerical stability tests
    RUN_TEST(test_ekf6_no_nan_output);
    RUN_TEST(test_ekf6_zero_dt_handling);
    RUN_TEST(test_ekf6_large_attitude_stability);

    // Configuration test
    RUN_TEST(test_ekf6_custom_config);

    // Alpha covariance reset tests
    RUN_TEST(test_ekf6_reset_alpha_covariance_basic);
    RUN_TEST(test_ekf6_stale_alpha_without_reset);
    RUN_TEST(test_ekf6_reset_alpha_covariance_uninitialized);
    RUN_TEST(test_ekf6_reset_preserves_other_states);

    return UNITY_END();
}
